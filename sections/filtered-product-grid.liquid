{%- liquid
  comment
    Use current collection if on a collection page, otherwise use section setting
  endcomment
  if collection != blank
    assign collection_obj = collection
    assign section_title = section.settings.title | default: collection.title | default: 'Products'
  elsif section.settings.collection != blank
    assign collection_handle = section.settings.collection
    assign collection_obj = collections[collection_handle]
    assign section_title = section.settings.title | default: collection_obj.title | default: 'Products'
  else
    assign collection_obj = blank
    assign section_title = section.settings.title | default: 'Products'
  endif
  
  assign products_per_page = section.settings.products_per_page | default: 9
  
  comment
    Calculate price range from collection products
  endcomment
  assign min_price = 0
  assign max_price = 100000
  
  if collection_obj != blank and collection_obj.products.size > 0
    for product in collection_obj.products
      if product.price < min_price or min_price == 0
        assign min_price = product.price
      endif
      if product.price > max_price
        assign max_price = product.price
      endif
    endfor
  endif
-%}

<section class="filtered-product-grid" id="filtered-product-grid-{{ section.id }}" data-section-id="{{ section.id }}">
  <div class="filtered-product-grid__container">
    <div class="filtered-product-grid__layout">
      <!-- Left Sidebar - Filters -->
      <aside class="filtered-product-grid__sidebar">
        <div class="filtered-product-grid__filters-header">
          <h3 class="filtered-product-grid__filters-title">Filters</h3>
          <button type="button" class="filtered-product-grid__filters-toggle" data-filters-toggle aria-label="Toggle filters">
            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
        </div>
        <div class="filtered-product-grid__filters" data-filters-content>
          <!-- Price Filter -->
          <div class="filter__group">
            <h3 class="filter__title">Price</h3>
            <div class="filter__price-inputs">
              <input 
                type="text" 
                class="filter__price-input" 
                id="price-min-{{ section.id }}"
                value="{{ min_price | money | remove: '.00' }}"
                data-price-min
              >
              <span class="filter__price-separator">To</span>
              <input 
                type="text" 
                class="filter__price-input" 
                id="price-max-{{ section.id }}"
                value="{{ max_price | money | remove: '.00' }}"
                data-price-max
              >
            </div>
            <div class="filter__price-slider" data-price-slider>
              <input 
                type="range" 
                class="filter__slider filter__slider--min" 
                min="{{ min_price }}" 
                max="{{ max_price }}" 
                value="{{ min_price }}"
                data-slider-min
                data-min-price="{{ min_price }}"
                data-max-price="{{ max_price }}"
              >
              <input 
                type="range" 
                class="filter__slider filter__slider--max" 
                min="{{ min_price }}" 
                max="{{ max_price }}" 
                value="{{ max_price }}"
                data-slider-max
                data-min-price="{{ min_price }}"
                data-max-price="{{ max_price }}"
              >
            </div>
          </div>

          <!-- Availability Toggle -->
          <div class="filter__group">
            <label class="filter__toggle">
              <input type="checkbox" class="filter__toggle-input" data-availability-filter>
              <span class="filter__toggle-slider"></span>
              <span class="filter__toggle-label">Only available items</span>
            </label>
          </div>

          <!-- Filter Categories -->
          {%- for block in section.blocks -%}
            {%- if block.type == 'filter_group' -%}
              <div class="filter__group filter__group--collapsible" {{ block.shopify_attributes }}>
                <details class="filter__details">
                  <summary class="filter__summary">
                    <h3 class="filter__title">{{ block.settings.title }}</h3>
                    <svg class="filter__chevron" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                  </summary>
                  <div class="filter__options">
                    {%- if block.settings.filter_type == 'product_option' -%}
                      {%- assign option_name = block.settings.option_name -%}
                      {%- assign unique_values = '' -%}
                      {%- for product in collection_obj.products -%}
                        {%- for option in product.options_with_values -%}
                          {%- if option.name == option_name -%}
                            {%- for value in option.values -%}
                              {%- unless unique_values contains value -%}
                                {%- assign unique_values = unique_values | append: value | append: ',' -%}
                              {%- endunless -%}
                            {%- endfor -%}
                          {%- endif -%}
                        {%- endfor -%}
                      {%- endfor -%}
                      {%- assign values_array = unique_values | split: ',' -%}
                      {%- for value in values_array -%}
                        {%- if value != blank -%}
                          {%- assign count = 0 -%}
                          {%- for product in collection_obj.products -%}
                            {%- for option in product.options_with_values -%}
                              {%- if option.name == option_name and option.selected_value == value -%}
                                {%- assign count = count | plus: 1 -%}
                              {%- endif -%}
                            {%- endfor -%}
                          {%- endfor -%}
                          <label class="filter__option">
                            <input 
                              type="checkbox" 
                              class="filter__checkbox" 
                              data-filter-option="{{ option_name | handleize }}"
                              data-filter-value="{{ value | handleize }}"
                              value="{{ value }}"
                            >
                            <span class="filter__option-label">
                              {{ value }}{% if count > 0 %}({{ count }}){% endif %}
                            </span>
                          </label>
                        {%- endif -%}
                      {%- endfor -%}
                    {%- elsif block.settings.filter_type == 'product_tag' -%}
                      {%- assign tag_prefix = block.settings.tag_prefix -%}
                      {%- assign unique_tags = '' -%}
                      {%- for product in collection_obj.products -%}
                        {%- for tag in product.tags -%}
                          {%- if tag contains tag_prefix -%}
                            {%- assign tag_value = tag | remove: tag_prefix | strip -%}
                            {%- unless unique_tags contains tag_value -%}
                              {%- assign unique_tags = unique_tags | append: tag_value | append: ',' -%}
                            {%- endunless -%}
                          {%- endif -%}
                        {%- endfor -%}
                      {%- endfor -%}
                      {%- assign tags_array = unique_tags | split: ',' -%}
                      {%- for tag_value in tags_array -%}
                        {%- if tag_value != blank -%}
                          {%- liquid
                            assign count = 0
                            assign full_tag = tag_prefix | append: tag_value
                          -%}
                          {%- for product in collection_obj.products -%}
                            {%- if product.tags contains full_tag -%}
                              {%- assign count = count | plus: 1 -%}
                            {%- endif -%}
                          {%- endfor -%}
                          <label class="filter__option">
                            <input 
                              type="checkbox" 
                              class="filter__checkbox" 
                              data-filter-tag="{{ tag_prefix | handleize }}"
                              data-filter-value="{{ tag_value | handleize }}"
                              value="{{ tag_value }}"
                            >
                            <span class="filter__option-label">
                              {{ tag_value }}{% if count > 0 %}({{ count }}){% endif %}
                            </span>
                          </label>
                        {%- endif -%}
                      {%- endfor -%}
                    {%- elsif block.settings.filter_type == 'vendor' -%}
                      {%- assign unique_vendors = '' -%}
                      {%- for product in collection_obj.products -%}
                        {%- unless unique_vendors contains product.vendor -%}
                          {%- assign unique_vendors = unique_vendors | append: product.vendor | append: ',' -%}
                        {%- endunless -%}
                      {%- endfor -%}
                      {%- assign vendors_array = unique_vendors | split: ',' -%}
                      {%- for vendor in vendors_array -%}
                        {%- if vendor != blank -%}
                          {%- assign count = 0 -%}
                          {%- for product in collection_obj.products -%}
                            {%- if product.vendor == vendor -%}
                              {%- assign count = count | plus: 1 -%}
                            {%- endif -%}
                          {%- endfor -%}
                          <label class="filter__option">
                            <input 
                              type="checkbox" 
                              class="filter__checkbox" 
                              data-filter-vendor
                              data-filter-value="{{ vendor | handleize }}"
                              value="{{ vendor }}"
                            >
                            <span class="filter__option-label">
                              {{ vendor }}{% if count > 0 %} ({{ count }}){% endif %}
                            </span>
                          </label>
                        {%- endif -%}
                      {%- endfor -%}
                    {%- elsif block.settings.filter_type == 'metafield' -%}
                      {%- comment -%} Metafield filtering would require specific metafield setup {%- endcomment -%}
                      <p class="filter__note">Configure metafield filters in theme settings</p>
                    {%- endif -%}
                  </div>
                </details>
              </div>
            {%- endif -%}
          {%- endfor -%}
        </div>
      </aside>

      <!-- Main Content Area -->
      <main class="filtered-product-grid__main">
        <h1 class="filtered-product-grid__title">{{ section_title }}</h1>
        {%- comment -%} Mobile Filter Button {%- endcomment -%}
        <button type="button" class="filtered-product-grid__filter-trigger" data-filter-drawer-trigger aria-label="Open filters">
          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M2 4H18M5 10H15M8 16H12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
          <span>Filters</span>
        </button>
        <div class="filtered-product-grid__carousel-wrapper">
          <div class="filtered-product-grid__carousel" data-filtered-carousel>
            <div class="filtered-product-grid__products" data-product-grid data-collection-handle="{{ collection_obj.handle | default: '' }}" data-min-price="{{ min_price }}" data-max-price="{{ max_price }}">
          {%- if collection_obj != blank and collection_obj.products.size > 0 -%}
            {%- for product in collection_obj.products limit: products_per_page -%}
              {%- liquid
                assign compare_at_price = product.compare_at_price
                assign price = product.price
                
                if compare_at_price > price
                  assign discount_percentage = compare_at_price | minus: price | times: 100 | divided_by: compare_at_price | round
                endif
                
                comment
                  Build data attributes for filtering
                endcomment
                assign product_data_options = ''
                assign product_data_tags = ''
                assign product_data_vendor = product.vendor | handleize
                
                for option in product.options_with_values
                  assign option_name_handle = option.name | handleize
                  for value in option.values
                    assign value_handle = value | handleize
                    assign product_data_options = product_data_options | append: option_name_handle | append: ':' | append: value_handle | append: ','
                  endfor
                endfor
                
                for tag in product.tags
                  comment
                    Store tag as-is (Shopify tags can have colons, dashes, etc.)
                    We'll handleize during comparison in JavaScript
                  endcomment
                  assign product_data_tags = product_data_tags | append: tag | append: ','
                endfor
              -%}
              <article class="filtered-product-card" 
                data-product-price="{{ price }}"
                data-product-vendor="{{ product_data_vendor }}"
                data-product-options="{{ product_data_options }}"
                data-product-tags="{{ product_data_tags }}"
              >
                {%- if discount_percentage -%}
                  <div class="filtered-product-card__badge">
                    {{ discount_percentage }}% off
                  </div>
                {%- endif -%}

                <a href="{{ product.url }}" class="filtered-product-card__link">
                  <div class="filtered-product-card__image">
                    {%- if product.featured_image != blank -%}
                      <img 
                        src="{{ product.featured_image | image_url: width: 400 }}"
                        alt="{{ product.featured_image.alt | default: product.title }}"
                        width="400"
                        height="300"
                        loading="lazy"
                      >
                    {%- else -%}
                      <div class="filtered-product-card__placeholder">
                        {{ 'product-1' | placeholder_svg_tag: 'placeholder-svg' }}
                      </div>
                    {%- endif -%}
                  </div>

                  <div class="filtered-product-card__info">
                    <div class="filtered-product-card__header">
                      <h3 class="filtered-product-card__title">{{ product.title }}</h3>
                      {%- if product.metafields.reviews.rating.value -%}
                        <div class="filtered-product-card__rating">
                          {%- assign rating = product.metafields.reviews.rating.value | round -%}
                          {%- for i in (1..5) -%}
                            <svg class="filtered-product-card__star{% if i <= rating %} filtered-product-card__star--filled{% endif %}" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
                              <path d="M7 1L8.5 5H12.5L9 8L10.5 12L7 9.5L3.5 12L5 8L1.5 5H5.5L7 1Z" fill="currentColor"/>
                            </svg>
                          {%- endfor -%}
                          {%- if product.metafields.reviews.rating_count.value -%}
                            <span class="filtered-product-card__rating-count">({{ product.metafields.reviews.rating_count.value }})</span>
                          {%- endif -%}
                        </div>
                      {%- endif -%}
                    </div>

                    <p class="filtered-product-card__description">
                      {{ product.description | strip_html | truncate: 120 }}
                    </p>
                  </div>
                </a>

                <div class="filtered-product-card__footer">
                  <div class="filtered-product-card__price">
                    {{ price | money }}
                  </div>
                  <div class="filtered-product-card__actions">
                    <a href="{{ product.url }}" class="filtered-product-card__btn filtered-product-card__btn--primary">
                      View Details
                    </a>
                    <button type="button" class="filtered-product-card__btn filtered-product-card__btn--secondary" data-add-to-cart data-variant-id="{{ product.selected_or_first_available_variant.id }}">
                      Add to cart
                    </button>
                  </div>
                </div>
              </article>
            {%- endfor -%}
          {%- else -%}
            <p class="filtered-product-grid__empty">No products available in this collection.</p>
          {%- endif -%}
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>

  {%- comment -%} Mobile Filter Drawer {%- endcomment -%}
  <div class="filtered-product-grid__filter-drawer" data-filter-drawer aria-hidden="true">
    <div class="filtered-product-grid__filter-overlay" data-filter-overlay></div>
    <div class="filtered-product-grid__filter-panel" data-filter-panel>
      <div class="filtered-product-grid__filter-drawer-header">
        <h3 class="filtered-product-grid__filter-drawer-title">Filters</h3>
        <button type="button" class="filtered-product-grid__filter-drawer-close" data-filter-drawer-close aria-label="Close filters">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 4L20 20M20 4L4 20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </button>
      </div>
      <div class="filtered-product-grid__filter-drawer-content">
        {%- comment -%} Price Filter {%- endcomment -%}
        <div class="filter__group">
          <h3 class="filter__title">Price</h3>
          <div class="filter__price-inputs">
            <input 
              type="text" 
              class="filter__price-input" 
              id="price-min-drawer-{{ section.id }}"
              value="{{ min_price | money | remove: '.00' }}"
              data-price-min-drawer
            >
            <span class="filter__price-separator">To</span>
            <input 
              type="text" 
              class="filter__price-input" 
              id="price-max-drawer-{{ section.id }}"
              value="{{ max_price | money | remove: '.00' }}"
              data-price-max-drawer
            >
          </div>
          <div class="filter__price-slider" data-price-slider-drawer>
            <input 
              type="range" 
              class="filter__slider filter__slider--min" 
              min="{{ min_price }}" 
              max="{{ max_price }}" 
              value="{{ min_price }}"
              data-slider-min-drawer
              data-min-price="{{ min_price }}"
              data-max-price="{{ max_price }}"
            >
            <input 
              type="range" 
              class="filter__slider filter__slider--max" 
              min="{{ min_price }}" 
              max="{{ max_price }}" 
              value="{{ max_price }}"
              data-slider-max-drawer
              data-min-price="{{ min_price }}"
              data-max-price="{{ max_price }}"
            >
          </div>
        </div>

        {%- comment -%} Availability Toggle {%- endcomment -%}
        <div class="filter__group">
          <label class="filter__toggle">
            <input type="checkbox" class="filter__toggle-input" data-availability-filter-drawer>
            <span class="filter__toggle-slider"></span>
            <span class="filter__toggle-label">Only available items</span>
          </label>
        </div>

        {%- comment -%} Filter Categories {%- endcomment -%}
        {%- for block in section.blocks -%}
          {%- if block.type == 'filter_group' -%}
            <div class="filter__group filter__group--collapsible" {{ block.shopify_attributes }}>
              <details class="filter__details" open>
                <summary class="filter__summary">
                  <h3 class="filter__title">{{ block.settings.title }}</h3>
                  <svg class="filter__chevron" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </summary>
                <div class="filter__options">
                  {%- if block.settings.filter_type == 'product_option' -%}
                    {%- assign option_name = block.settings.option_name -%}
                    {%- assign unique_values = '' -%}
                    {%- for product in collection_obj.products -%}
                      {%- for option in product.options_with_values -%}
                        {%- if option.name == option_name -%}
                          {%- for value in option.values -%}
                            {%- unless unique_values contains value -%}
                              {%- assign unique_values = unique_values | append: value | append: ',' -%}
                            {%- endunless -%}
                          {%- endfor -%}
                        {%- endif -%}
                      {%- endfor -%}
                    {%- endfor -%}
                    {%- assign values_array = unique_values | split: ',' -%}
                    {%- for value in values_array -%}
                      {%- if value != blank -%}
                        {%- assign count = 0 -%}
                        {%- for product in collection_obj.products -%}
                          {%- for option in product.options_with_values -%}
                            {%- if option.name == option_name and option.selected_value == value -%}
                              {%- assign count = count | plus: 1 -%}
                            {%- endif -%}
                          {%- endfor -%}
                        {%- endfor -%}
                        <label class="filter__option">
                          <input 
                            type="checkbox" 
                            class="filter__checkbox" 
                            data-filter-option="{{ option_name | handleize }}"
                            data-filter-value="{{ value | handleize }}"
                            data-filter-drawer
                            value="{{ value }}"
                          >
                          <span class="filter__option-label">
                            {{ value }}{% if count > 0 %}({{ count }}){% endif %}
                          </span>
                        </label>
                      {%- endif -%}
                    {%- endfor -%}
                  {%- elsif block.settings.filter_type == 'product_tag' -%}
                    {%- assign tag_prefix = block.settings.tag_prefix -%}
                    {%- assign unique_tags = '' -%}
                    {%- for product in collection_obj.products -%}
                      {%- for tag in product.tags -%}
                        {%- if tag contains tag_prefix -%}
                          {%- assign tag_value = tag | remove: tag_prefix | strip -%}
                          {%- unless unique_tags contains tag_value -%}
                            {%- assign unique_tags = unique_tags | append: tag_value | append: ',' -%}
                          {%- endunless -%}
                        {%- endif -%}
                      {%- endfor -%}
                    {%- endfor -%}
                    {%- assign tags_array = unique_tags | split: ',' -%}
                    {%- for tag_value in tags_array -%}
                      {%- if tag_value != blank -%}
                        {%- liquid
                          assign count = 0
                          assign full_tag = tag_prefix | append: tag_value
                        -%}
                        {%- for product in collection_obj.products -%}
                          {%- if product.tags contains full_tag -%}
                            {%- assign count = count | plus: 1 -%}
                          {%- endif -%}
                        {%- endfor -%}
                        <label class="filter__option">
                          <input 
                            type="checkbox" 
                            class="filter__checkbox" 
                            data-filter-tag="{{ tag_prefix | handleize }}"
                            data-filter-value="{{ tag_value | handleize }}"
                            data-filter-drawer
                            value="{{ tag_value }}"
                          >
                          <span class="filter__option-label">
                            {{ tag_value }}{% if count > 0 %}({{ count }}){% endif %}
                          </span>
                        </label>
                      {%- endif -%}
                    {%- endfor -%}
                  {%- elsif block.settings.filter_type == 'vendor' -%}
                    {%- assign unique_vendors = '' -%}
                    {%- for product in collection_obj.products -%}
                      {%- unless unique_vendors contains product.vendor -%}
                        {%- assign unique_vendors = unique_vendors | append: product.vendor | append: ',' -%}
                      {%- endunless -%}
                    {%- endfor -%}
                    {%- assign vendors_array = unique_vendors | split: ',' -%}
                    {%- for vendor in vendors_array -%}
                      {%- if vendor != blank -%}
                        {%- assign count = 0 -%}
                        {%- for product in collection_obj.products -%}
                          {%- if product.vendor == vendor -%}
                            {%- assign count = count | plus: 1 -%}
                          {%- endif -%}
                        {%- endfor -%}
                        <label class="filter__option">
                          <input 
                            type="checkbox" 
                            class="filter__checkbox" 
                            data-filter-vendor
                            data-filter-value="{{ vendor | handleize }}"
                            data-filter-drawer
                            value="{{ vendor }}"
                          >
                          <span class="filter__option-label">
                            {{ vendor }}{% if count > 0 %} ({{ count }}){% endif %}
                          </span>
                        </label>
                      {%- endif -%}
                    {%- endfor -%}
                  {%- endif -%}
                </div>
              </details>
            </div>
          {%- endif -%}
        {%- endfor -%}
      </div>
      <div class="filtered-product-grid__filter-drawer-footer">
        <button type="button" class="filtered-product-grid__filter-apply" data-filter-apply>Apply Filters</button>
        <button type="button" class="filtered-product-grid__filter-clear" data-filter-clear>Clear All</button>
      </div>
    </div>
  </div>
</section>

{% stylesheet %}
.filtered-product-grid {
  padding: 40px 0;
  background-color: var(--color-white);
  width: 100%;
  max-width: 100%;
  overflow-x: hidden;
  box-sizing: border-box;
}

.filtered-product-grid__container {
  max-width: var(--container-max);
  margin: 0 auto;
  padding: 0 var(--container-padding);
  width: 100%;
  box-sizing: border-box;
  overflow-x: hidden;
}

/* Mobile-first: Default to single column layout */
.filtered-product-grid__layout {
  display: grid;
  grid-template-columns: 1fr;
  gap: 24px;
  align-items: start;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

/* Mobile-first: Sidebar hidden by default */
.filtered-product-grid__sidebar {
  display: none;
  visibility: hidden;
  position: relative;
  top: 0;
  width: 100%;
  max-width: 100%;
}

/* Mobile-first: Show filters header by default */
.filtered-product-grid__filters-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid var(--color-gray);
}

.filtered-product-grid__filters-title {
  font-family: var(--font-heading);
  font-weight: 500;
  font-size: 18px;
  line-height: normal;
  color: var(--color-black);
  margin: 0;
}

/* Mobile-first: Show filters toggle by default */
.filtered-product-grid__filters-toggle {
  display: block;
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  color: var(--color-black);
  transition: transform var(--transition-fast);
}

.filtered-product-grid__filters-toggle svg {
  width: 16px;
  height: 16px;
  transition: transform var(--transition-fast);
}

.filtered-product-grid__filters-toggle[aria-expanded="true"] svg {
  transform: rotate(180deg);
}

/* Mobile-first: Filters collapsed by default */
.filtered-product-grid__filters {
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.filtered-product-grid__filters[data-filters-collapsed="true"] {
  display: none;
}

/* Desktop: Show sidebar and adjust layout */
/* !important needed to override mobile display:none when switching viewport sizes */
@media screen and (min-width: 993px) {
  .filtered-product-grid__layout {
    grid-template-columns: 280px 1fr;
    gap: 40px;
  }

  .filtered-product-grid__sidebar {
    display: block !important;
    position: sticky;
    top: 100px;
    width: auto;
    max-width: none;
  }

  .filtered-product-grid__filters-header {
    display: none;
  }

  .filtered-product-grid__filters-toggle {
    display: none;
  }
  
  .filtered-product-grid__filters {
    display: flex !important;
  }
  
  .filtered-product-grid__filters[data-filters-collapsed] {
    display: flex !important;
  }
}

/* Medium desktop: Adjust sidebar width */
@media screen and (min-width: 1201px) {
  .filtered-product-grid__layout {
    grid-template-columns: 240px 1fr;
    gap: 32px;
  }
}

.filter__group {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding-bottom: 24px;
  border-bottom: 1px solid var(--color-gray);
}

.filter__group:last-child {
  border-bottom: none;
}

.filter__group--collapsible {
  padding-bottom: 0;
  border-bottom: none;
}

.filter__title {
  font-family: var(--font-heading);
  font-weight: 500;
  font-size: 16px;
  line-height: normal;
  color: var(--color-black);
  margin: 0;
}

.filter__details {
  border-bottom: 1px solid var(--color-gray);
  padding-bottom: 24px;
}

.filter__summary {
  display: flex;
  align-items: center;
  justify-content: space-between;
  list-style: none;
  cursor: pointer;
  gap: 12px;
  padding: 8px 0;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.filter__summary::-webkit-details-marker {
  display: none;
}

.filter__summary::marker {
  display: none;
}

.filter__chevron {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
  transition: transform var(--transition-fast);
  color: var(--color-black);
}

.filter__details[open] .filter__chevron {
  transform: rotate(180deg);
}

.filter__price-inputs {
  display: flex;
  align-items: center;
  gap: 8px;
}

.filter__price-input {
  flex: 1;
  min-width: 0;
  padding: 8px 12px;
  font-family: var(--font-body);
  font-size: 14px;
  border: 1px solid var(--color-black);
  border-radius: 4px;
  background-color: var(--color-white);
  width: 116px;
}

.filter__price-separator {
  font-family: var(--font-body);
  font-size: 14px;
  color: var(--color-black);
}

.filter__price-slider {
  position: relative;
  height: 4px;
  background-color: var(--color-gray);
  border-radius: 2px;
  margin-top: 8px;
}

.filter__slider {
  position: absolute;
  width: 100%;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  pointer-events: none;
}

.filter__slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  background-color: var(--color-blue);
  border: 2px solid var(--color-black);
  border-radius: 50%;
  cursor: pointer;
  pointer-events: all;
  box-shadow: 2px 2px 0px 0px var(--color-black);
}

.filter__slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background-color: var(--color-blue);
  border: 2px solid var(--color-black);
  border-radius: 50%;
  cursor: pointer;
  pointer-events: all;
  box-shadow: 2px 2px 0px 0px var(--color-black);
}

.filter__slider--min {
  z-index: 2;
}

.filter__slider--max {
  z-index: 1;
}

.filter__toggle {
  display: flex;
  align-items: center;
  gap: 12px;
  cursor: pointer;
  padding: 4px 0;
  -webkit-tap-highlight-color: transparent;
}

.filter__toggle-input {
  display: none;
}

.filter__toggle-slider {
  position: relative;
  width: 44px;
  height: 24px;
  background-color: var(--color-gray);
  border: 1px solid var(--color-black);
  border-radius: 12px;
  transition: background-color var(--transition-fast);
}

.filter__toggle-slider::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 18px;
  height: 18px;
  background-color: var(--color-white);
  border: 1px solid var(--color-black);
  border-radius: 50%;
  transition: transform var(--transition-fast);
  box-shadow: 1px 1px 0px 0px var(--color-black);
}

.filter__toggle-input:checked + .filter__toggle-slider {
  background-color: var(--color-green);
}

.filter__toggle-input:checked + .filter__toggle-slider::after {
  transform: translateX(20px);
}

.filter__toggle-label {
  font-family: var(--font-body);
  font-size: 14px;
  color: var(--color-black);
}

.filter__options {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 16px;
}

.filter__option {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  padding: 4px 0;
  -webkit-tap-highlight-color: transparent;
}

.filter__checkbox {
  width: 18px;
  height: 18px;
  cursor: pointer;
  accent-color: var(--color-blue);
  border: 1px solid var(--color-black);
}

.filter__option-label {
  font-family: var(--font-body);
  font-size: 14px;
  color: var(--color-black);
}

.filter__note {
  font-family: var(--font-body);
  font-size: 12px;
  color: var(--color-text-secondary);
  font-style: italic;
  margin: 0;
}

.filtered-product-grid__main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  overflow-x: hidden;
}

.filtered-product-grid__title {
  font-family: var(--font-heading);
  font-weight: 500;
  font-size: 32px;
  line-height: normal;
  color: var(--color-black);
  margin: 0;
}

/* Mobile-first: Show filter trigger button by default */
.filtered-product-grid__filter-trigger {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 20px;
  margin-bottom: 20px;
  font-family: var(--font-heading);
  font-weight: 500;
  font-size: 16px;
  line-height: 1;
  color: var(--color-black);
  background-color: var(--color-white);
  border: 2px solid var(--color-black);
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-md);
  cursor: pointer;
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
  width: 100%;
  justify-content: center;
  /* Ensure button is accessible and touchable */
  touch-action: manipulation;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
  user-select: none;
  -webkit-user-select: none;
  /* Minimum touch target size for accessibility */
  min-height: 44px;
}

/* Desktop: Hide filter trigger button */
@media screen and (min-width: 769px) {
  .filtered-product-grid__filter-trigger {
    display: none;
  }
}

.filtered-product-grid__filter-trigger:hover {
  transform: translate(-2px, -2px);
  box-shadow: var(--shadow-lg);
}

.filtered-product-grid__filter-trigger:active {
  transform: translate(2px, 2px);
  box-shadow: var(--shadow-xs);
}

.filtered-product-grid__filter-trigger svg {
  width: 20px;
  height: 20px;
  flex-shrink: 0;
}

.filtered-product-grid__carousel-wrapper {
  position: relative;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  overflow-x: hidden;
}

.filtered-product-grid__carousel {
  position: relative;
  overflow: hidden;
  padding-bottom: 4px;
  padding-right: 4px;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

/* Mobile-first: Default to horizontal scroll layout */
.filtered-product-grid__products {
  display: flex;
  gap: 16px;
  overflow-x: auto;
  scroll-snap-type: x mandatory;
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
  -ms-overflow-style: none;
  padding-left: 7.5%;
  padding-right: calc(7.5% + 4px);
  padding-bottom: 4px;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  margin: 0;
  transition: transform 0.3s ease-in-out;
}

.filtered-product-grid__products::-webkit-scrollbar {
  display: none;
}

.filtered-product-grid__products .filtered-product-card {
  flex: 0 0 85%;
  min-width: 85%;
  max-width: 85%;
  scroll-snap-align: center;
}

/* Tablet: 2 column grid */
@media screen and (min-width: 577px) {
  .filtered-product-grid__products {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    overflow-x: visible;
    scroll-snap-type: none;
    padding-left: 0;
    padding-right: 0;
    margin-bottom: 4px;
  }

  .filtered-product-grid__products .filtered-product-card {
    flex: none;
    min-width: auto;
    max-width: none;
  }
}

/* Desktop: 3 column grid */
@media screen and (min-width: 993px) {
  .filtered-product-grid__products {
    grid-template-columns: repeat(3, 1fr);
    gap: 24px;
  }
}

.filtered-product-grid__empty {
  grid-column: 1 / -1;
  text-align: center;
  padding: 40px 20px;
  font-family: var(--font-body);
  font-size: 16px;
  color: var(--color-text-secondary);
}

/* Custom Product Card Styles for Filtered Grid */
.filtered-product-card {
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 15px;
  padding: 17px;
  background-color: var(--color-white);
  border: 0.5px solid var(--color-black);
  border-radius: 6px;
  box-shadow: 4px 4px 0px 0px var(--color-black);
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
}

.filtered-product-card:hover {
  transform: translate(-2px, -2px);
  box-shadow: 6px 6px 0px 0px var(--color-black);
}

.filtered-product-card__badge {
  position: absolute;
  top: 0;
  left: 0;
  padding: 4px 12px;
  font-family: var(--font-body);
  font-weight: 500;
  font-size: 14px;
  color: var(--color-white);
  background-color: var(--color-blue);
  border-radius: 0 2px 0 0;
  box-shadow: 1px 2px 0px 0.5px var(--color-black);
  z-index: 2;
}

.filtered-product-card__link {
  display: flex;
  flex-direction: column;
  gap: 15px;
  text-decoration: none;
  color: inherit;
}

.filtered-product-card__image {
  position: relative;
  width: 100%;
  aspect-ratio: 1.7;
  overflow: hidden;
}

.filtered-product-card__image img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.filtered-product-card__placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--color-gray);
}

.filtered-product-card__placeholder svg {
  width: 60%;
  height: 60%;
  opacity: 0.5;
}

.filtered-product-card__info {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.filtered-product-card__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}

.filtered-product-card__title {
  font-family: var(--font-product);
  font-weight: 700;
  font-size: 17px;
  line-height: 1.2;
  color: var(--color-black);
  margin: 0;
}

.filtered-product-card__rating {
  display: flex;
  gap: 2px;
}

.filtered-product-card__star {
  color: var(--color-gray);
}

.filtered-product-card__star--filled {
  color: var(--color-star);
}

.filtered-product-card__rating-count {
  font-family: var(--font-body);
  font-size: 12px;
  color: var(--color-text-secondary);
  margin-left: 4px;
}

.filtered-product-card__description {
  font-family: var(--font-body);
  font-weight: 500;
  font-size: 12px;
  line-height: 1.4;
  color: var(--color-black);
  margin: 0;
}

.filtered-product-card__footer {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.filtered-product-card__price {
  font-family: Overpass;
  font-weight: 700;
  font-size: 18px;
  color: var(--color-black);
  text-align: center;
}

.filtered-product-card__actions {
  display: flex;
  gap: 10px;
}

.filtered-product-card__btn {
  flex: 1;
  padding: 12px 16px;
  font-family: var(--font-heading);
  font-weight: 600;
  font-size: 14px;
  text-align: center;
  text-decoration: none;
  border: 2px solid var(--color-black);
  border-radius: 4px;
  box-shadow: 3px 3px 0px 0px var(--color-black);
  cursor: pointer;
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
  white-space: nowrap;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.filtered-product-card__btn--primary {
  background-color: var(--color-green);
  color: var(--color-black);
}

.filtered-product-card__btn--secondary {
  background-color: rgba(177, 216, 255, 1);
  color: var(--color-black);
}

.filtered-product-card__btn:hover {
  transform: translate(-2px, -2px);
  box-shadow: 5px 5px 0px 0px var(--color-black);
}

.filtered-product-card__btn:active {
  transform: translate(1px, 1px);
  box-shadow: 1px 1px 0px 0px var(--color-black);
}

/* Mobile-specific adjustments */
@media screen and (max-width: 576px) {
  .filtered-product-grid__products {
    padding-left: 5%;
    padding-right: calc(5% + 4px);
    gap: 12px;
  }

  .filtered-product-grid__products .filtered-product-card {
    flex: 0 0 90%;
    min-width: 90%;
    max-width: 90%;
  }
}

@media screen and (max-width: 480px) {
  .filtered-product-grid__products {
    padding-left: 3%;
    padding-right: calc(3% + 4px);
    gap: 10px;
  }

  .filtered-product-grid__products .filtered-product-card {
    flex: 0 0 94%;
    min-width: 94%;
    max-width: 94%;
  }
}

@media screen and (max-width: 400px) {
  .filtered-product-grid__products {
    padding-left: 2%;
    padding-right: calc(2% + 4px);
    gap: 8px;
  }

  .filtered-product-grid__products .filtered-product-card {
    flex: 0 0 96%;
    min-width: 96%;
    max-width: 96%;
  }
}

/* Mobile Filter Drawer */
.filtered-product-grid__filter-drawer {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 9999;
  pointer-events: none;
  display: none;
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
}

/* Mobile-first: Drawer visible by default on mobile */
.filtered-product-grid__filter-drawer {
  display: block;
}

/* Desktop: Hide drawer */
@media screen and (min-width: 769px) {
  .filtered-product-grid__filter-drawer {
    display: none;
  }
}

/* Drawer open state - applies to all screen sizes but only visible on mobile */
/* !important needed to override default hidden state and ensure drawer is accessible when opened */
.filtered-product-grid__filter-drawer[aria-hidden="false"] {
  visibility: visible !important;
  pointer-events: all !important;
  opacity: 1 !important;
}

/* Ensure drawer is displayed on mobile when open */
/* !important needed to override default display:none and ensure drawer appears on mobile */
@media screen and (max-width: 768px) {
  .filtered-product-grid__filter-drawer[aria-hidden="false"] {
    display: block !important;
  }
}

.filtered-product-grid__filter-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  opacity: 0;
  transition: opacity var(--transition-base);
}

.filtered-product-grid__filter-drawer[aria-hidden="false"] .filtered-product-grid__filter-overlay {
  opacity: 1;
}

.filtered-product-grid__filter-panel {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  max-width: 400px;
  background-color: var(--color-white);
  box-shadow: -4px 0 20px rgba(0, 0, 0, 0.1);
  transform: translateX(100%);
  transition: transform 0.3s ease-in-out;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  will-change: transform;
  z-index: 10000;
  visibility: visible;
}

/* !important needed to override transform and ensure panel slides in correctly when drawer opens */
.filtered-product-grid__filter-drawer[aria-hidden="false"] .filtered-product-grid__filter-panel {
  transform: translateX(0) !important;
  display: flex !important;
  visibility: visible !important;
}

.filtered-product-grid__filter-drawer-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px;
  border-bottom: 1px solid var(--color-gray);
  flex-shrink: 0;
  position: sticky;
  top: 0;
  background-color: var(--color-white);
  z-index: 1;
}

.filtered-product-grid__filter-drawer-title {
  font-family: var(--font-heading);
  font-weight: 500;
  font-size: 20px;
  line-height: normal;
  color: var(--color-black);
  margin: 0;
}

.filtered-product-grid__filter-drawer-close {
  background: none;
  border: none;
  cursor: pointer;
  padding: 8px;
  color: var(--color-black);
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 44px;
  min-height: 44px;
  border-radius: 4px;
  transition: background-color var(--transition-fast);
}

.filtered-product-grid__filter-drawer-close:hover {
  background-color: var(--color-gray);
}

.filtered-product-grid__filter-drawer-close svg {
  width: 24px;
  height: 24px;
}

.filtered-product-grid__filter-drawer-content {
  flex: 1;
  padding: 20px;
  overflow-y: auto;
}

.filtered-product-grid__filter-drawer-footer {
  display: flex;
  gap: 12px;
  padding: 20px;
  border-top: 1px solid var(--color-gray);
  flex-shrink: 0;
  position: sticky;
  bottom: 0;
  background-color: var(--color-white);
  z-index: 1;
}

.filtered-product-grid__filter-apply,
.filtered-product-grid__filter-clear {
  flex: 1;
  padding: 14px 20px;
  font-family: var(--font-heading);
  font-weight: 500;
  font-size: 16px;
  line-height: 1;
  text-align: center;
  border: 2px solid var(--color-black);
  border-radius: var(--radius-sm);
  cursor: pointer;
  transition: transform var(--transition-fast), box-shadow var(--transition-fast);
  min-height: 44px;
}

.filtered-product-grid__filter-apply {
  color: var(--color-white);
  background-color: var(--color-navy);
  box-shadow: var(--shadow-md);
}

.filtered-product-grid__filter-apply:hover {
  transform: translate(-2px, -2px);
  box-shadow: var(--shadow-lg);
}

.filtered-product-grid__filter-apply:active {
  transform: translate(2px, 2px);
  box-shadow: var(--shadow-xs);
}

.filtered-product-grid__filter-clear {
  color: var(--color-black);
  background-color: var(--color-white);
  box-shadow: var(--shadow-sm);
}

.filtered-product-grid__filter-clear:hover {
  transform: translate(-2px, -2px);
  box-shadow: var(--shadow-md);
}

.filtered-product-grid__filter-clear:active {
  transform: translate(2px, 2px);
  box-shadow: 1px 1px 0px 0px var(--color-black);
}

/* Mobile-first: Base mobile styles (applied by default) */
.filtered-product-grid {
  padding: 24px 0;
  width: 100%;
  max-width: 100%;
  overflow-x: hidden;
  box-sizing: border-box;
}

.filtered-product-grid__container {
  padding: 0 16px;
  max-width: 100%;
  width: 100%;
  box-sizing: border-box;
  overflow-x: hidden;
}

.filtered-product-grid__title {
  font-size: 24px;
  width: 100%;
  box-sizing: border-box;
}

.filtered-product-grid__main {
  position: relative;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  overflow-x: hidden;
  padding: 0;
  margin: 0;
}

.filtered-product-grid__carousel {
  overflow: visible;
  padding-bottom: 4px;
  padding-right: 0;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

.filtered-product-grid__carousel-wrapper {
  width: 100%;
  max-width: 100%;
  overflow-x: hidden;
  box-sizing: border-box;
  position: relative;
}

.filtered-product-card {
  padding: 14px;
  gap: 12px;
}

.filtered-product-card__price {
  font-size: 16px;
}

.filtered-product-card__btn {
  padding: 10px 14px;
  font-size: 13px;
}

/* Mobile drawer panel width */
.filtered-product-grid__filter-panel {
  max-width: 85%;
}

.filtered-product-grid__filter-drawer-header {
  padding: 16px;
}

.filtered-product-grid__filter-drawer-title {
  font-size: 18px;
}

.filtered-product-grid__filter-drawer-content {
  padding: 16px;
}

.filter__group {
  padding-bottom: 20px;
  gap: 12px;
}

.filter__title {
  font-size: 15px;
}

.filter__price-input {
  width: 100px;
  padding: 10px 12px;
  font-size: 14px;
}

.filter__option {
  min-height: 44px;
  padding: 8px 0;
}

.filter__checkbox {
  width: 20px;
  height: 20px;
  min-width: 20px;
  min-height: 20px;
}

.filtered-product-grid__filter-drawer-footer {
  padding: 16px;
  gap: 10px;
}

.filtered-product-grid__filter-apply,
.filtered-product-grid__filter-clear {
  padding: 12px 16px;
  font-size: 15px;
}

/* Desktop: Adjust styles for larger screens */
@media screen and (min-width: 769px) {
  .filtered-product-grid {
    padding: 40px 0;
  }

  .filtered-product-grid__container {
    padding: 0 var(--container-padding);
  }

  .filtered-product-grid__title {
    font-size: 32px;
  }

  .filtered-product-grid__main {
    padding: 0;
    margin: 0;
  }

  .filtered-product-grid__carousel {
    padding-right: 4px;
  }

  .filtered-product-card {
    padding: 17px;
    gap: 15px;
  }

  .filtered-product-card__price {
    font-size: 18px;
  }

  .filtered-product-card__btn {
    padding: 12px 16px;
    font-size: 14px;
  }

  .filtered-product-grid__filter-drawer-header {
    padding: 20px;
  }

  .filtered-product-grid__filter-drawer-title {
    font-size: 20px;
  }

  .filtered-product-grid__filter-drawer-content {
    padding: 20px;
  }

  .filter__group {
    padding-bottom: 24px;
    gap: 16px;
  }

  .filter__title {
    font-size: 16px;
  }

  .filter__price-input {
    width: 116px;
    padding: 8px 12px;
    font-size: 14px;
  }

  .filter__option {
    padding: 4px 0;
  }

  .filter__checkbox {
    width: 18px;
    height: 18px;
    min-width: 18px;
    min-height: 18px;
  }

  .filtered-product-grid__filter-drawer-footer {
    padding: 20px;
    gap: 12px;
  }

  .filtered-product-grid__filter-apply,
  .filtered-product-grid__filter-clear {
    padding: 14px 20px;
    font-size: 16px;
  }
}

@media screen and (max-width: 576px) {
  .filtered-product-grid__container {
    padding: 0 12px;
    max-width: 100%;
    width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__layout {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__main {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }

  .filtered-product-grid__title {
    font-size: 20px;
    width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__filter-trigger {
    padding: 10px 16px;
    font-size: 14px;
    margin-bottom: 16px;
  }

  .filtered-product-grid__filter-trigger svg {
    width: 18px;
    height: 18px;
  }

  .filtered-product-grid__carousel-wrapper {
    width: 100%;
    max-width: 100%;
    overflow-x: hidden;
    box-sizing: border-box;
  }

  .filtered-product-grid__carousel {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__products {
    padding-left: 5%;
    padding-right: calc(5% + 4px);
    padding-bottom: 4px;
    gap: 12px;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    margin: 0;
  }

  .filtered-product-grid__products .filtered-product-card {
    flex: 0 0 90%;
    min-width: 90%;
    max-width: 90%;
    scroll-snap-align: center;
    box-shadow: 4px 4px 0px 0px var(--color-black);
  }

  .filtered-product-card {
    padding: 12px;
    gap: 10px;
  }

  .filtered-product-card__title {
    font-size: 15px;
  }

  .filtered-product-card__description {
    font-size: 11px;
  }

  .filtered-product-card__price {
    font-size: 15px;
  }

  .filtered-product-card__btn {
    padding: 10px 12px;
    font-size: 12px;
  }

  /* Smaller drawer on very small screens */
  .filtered-product-grid__filter-panel {
    max-width: 90%;
  }

  .filtered-product-grid__filter-drawer-header {
    padding: 14px;
  }

  .filtered-product-grid__filter-drawer-title {
    font-size: 16px;
  }

  .filtered-product-grid__filter-drawer-content {
    padding: 14px;
  }

  .filter__group {
    padding-bottom: 16px;
    gap: 10px;
  }

  .filter__title {
    font-size: 14px;
  }

  .filter__price-inputs {
    flex-wrap: wrap;
    gap: 6px;
  }

  .filter__price-input {
    width: 90px;
    padding: 8px 10px;
    font-size: 13px;
  }

  .filter__option-label {
    font-size: 13px;
  }

  .filtered-product-grid__filter-drawer-footer {
    padding: 14px;
    gap: 8px;
    flex-direction: column;
  }

  .filtered-product-grid__filter-apply,
  .filtered-product-grid__filter-clear {
    width: 100%;
    padding: 12px 16px;
    font-size: 14px;
  }
}

@media screen and (max-width: 480px) {
  .filtered-product-grid__container {
    padding: 0 12px;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__layout {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__main {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }

  .filtered-product-grid__carousel-wrapper {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__products {
    padding-left: 3%;
    padding-right: calc(3% + 4px);
    gap: 10px;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__products .filtered-product-card {
    flex: 0 0 94%;
    min-width: 94%;
    max-width: 94%;
  }

  .filtered-product-grid__filters-header {
    margin-bottom: 10px;
    padding-bottom: 8px;
  }

  .filter__group {
    gap: 10px;
    padding-bottom: 12px;
  }

  .filter__price-inputs {
    flex-wrap: wrap;
    gap: 6px;
  }

  .filter__price-input {
    width: calc(50% - 3px);
    max-width: none;
    min-width: 80px;
  }

  .filter__price-separator {
    width: 100%;
    text-align: center;
    order: 3;
  }

  .filtered-product-card {
    padding: 10px;
  }

  .filtered-product-card__title {
    font-size: 14px;
  }

  .filtered-product-card__price {
    font-size: 14px;
  }

  .filtered-product-card__btn {
    font-size: 11px;
    padding: 9px 10px;
  }
}

@media screen and (max-width: 400px) {
  .filtered-product-grid__container {
    padding: 0 8px;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__layout {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__main {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }

  .filtered-product-grid__carousel-wrapper {
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__products {
    padding-left: 2%;
    padding-right: calc(2% + 4px);
    gap: 8px;
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
  }

  .filtered-product-grid__products .filtered-product-card {
    flex: 0 0 96%;
    min-width: 96%;
    max-width: 96%;
  }
}
{% endstylesheet %}

{% javascript %}
(function() {
  // Helper function to check if we're on mobile
  function isMobile() {
    return window.innerWidth <= 768;
  }

  // Helper function to find element with retry
  function findElementWithRetry(container, selector, retries = 3, delay = 100) {
    const element = container.querySelector(selector);
    if (element) return element;
    
    if (retries > 0) {
      return new Promise((resolve) => {
        setTimeout(() => {
          const retryElement = container.querySelector(selector);
          if (retryElement) {
            resolve(retryElement);
          } else {
            resolve(findElementWithRetry(container, selector, retries - 1, delay));
          }
        }, delay);
      });
    }
    
    return null;
  }

  // Wait for DOM to be ready
  function initFilteredProductGrid() {
    const sectionElement = document.querySelector('[id^="filtered-product-grid-"]');
    if (!sectionElement) {
      // Retry if element not found (might be loading)
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initFilteredProductGrid);
        return;
      }
      // Additional retry for slow-loading pages
      setTimeout(() => {
        const retrySection = document.querySelector('[id^="filtered-product-grid-"]');
        if (retrySection) {
          initFilteredProductGrid();
        } else {
          console.warn('Filtered product grid section not found after retry');
        }
      }, 500);
      return;
    }

    console.log('Initializing filtered product grid', sectionElement.id, {
      isMobile: isMobile(),
      viewportWidth: window.innerWidth
    });

  // Mobile Filter Drawer Elements - try multiple times for mobile
  // Using let here because these may be reassigned in the retry logic below
  let filterDrawer = sectionElement.querySelector('[data-filter-drawer]');
  let filterDrawerTrigger = sectionElement.querySelector('[data-filter-drawer-trigger]');
  let filterDrawerClose = sectionElement.querySelector('[data-filter-drawer-close]');
  let filterOverlay = sectionElement.querySelector('[data-filter-overlay]');
  let filterPanel = sectionElement.querySelector('[data-filter-panel]');

  // On mobile, retry finding elements if not found initially
  if (isMobile() && (!filterDrawer || !filterDrawerTrigger)) {
    console.log('Mobile detected - retrying to find drawer elements...');
    setTimeout(() => {
      if (!filterDrawer) filterDrawer = sectionElement.querySelector('[data-filter-drawer]');
      if (!filterDrawerTrigger) filterDrawerTrigger = sectionElement.querySelector('[data-filter-drawer-trigger]');
      if (!filterDrawerClose) filterDrawerClose = sectionElement.querySelector('[data-filter-drawer-close]');
      if (!filterOverlay) filterOverlay = sectionElement.querySelector('[data-filter-overlay]');
      if (!filterPanel) filterPanel = sectionElement.querySelector('[data-filter-panel]');
      
      console.log('Retry results:', {
        drawer: !!filterDrawer,
        trigger: !!filterDrawerTrigger,
        close: !!filterDrawerClose,
        overlay: !!filterOverlay,
        panel: !!filterPanel
      });
    }, 200);
  }

  console.log('Filter drawer elements found:', {
    drawer: !!filterDrawer,
    trigger: !!filterDrawerTrigger,
    close: !!filterDrawerClose,
    overlay: !!filterOverlay,
    panel: !!filterPanel,
    isMobile: isMobile()
  });

  // Body scroll lock helper
  function lockBodyScroll() {
    document.body.style.overflow = 'hidden';
  }

  function unlockBodyScroll() {
    document.body.style.overflow = '';
  }

  // Store reference to trigger button for focus management
  // Using let because this is reassigned when drawer opens
  let drawerTriggerButton = null;

  // Drawer open/close functions
  function openDrawer(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
      // Store the trigger button that opened the drawer
      drawerTriggerButton = e.target.closest('[data-filter-drawer-trigger]') || filterDrawerTrigger;
    }
    
    // Defensive check: ensure drawer exists
    if (!filterDrawer) {
      console.error('Filter drawer not found - cannot open drawer');
      return false;
    }
    
    // Check if drawer is already open
    if (filterDrawer.getAttribute('aria-hidden') === 'false') {
      console.log('Drawer is already open');
      return true;
    }
    
    // Ensure all required elements exist
    if (!filterPanel) {
      console.error('Filter panel not found - drawer may not display correctly');
    }
    
    console.log('Opening filter drawer', {
      drawer: !!filterDrawer,
      panel: !!filterPanel,
      overlay: !!filterOverlay,
      closeButton: !!filterDrawerClose
    });
    
    // Set drawer to visible state
    filterDrawer.setAttribute('aria-hidden', 'false');
    document.body.classList.add('drawer-open');
    lockBodyScroll();
    
    // Force reflow to ensure transition works
    void filterDrawer.offsetWidth;
    
    // Ensure panel is visible and properly displayed
    if (filterPanel) {
      filterPanel.style.display = 'flex';
      filterPanel.style.visibility = 'visible';
      // Force reflow for panel
      void filterPanel.offsetWidth;
    }
    
    // Focus the first focusable element in the drawer (close button)
    if (filterDrawerClose) {
      setTimeout(() => {
        filterDrawerClose.focus();
      }, 100);
    }
    
    return true;
  }

  function closeDrawer(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }
    if (!filterDrawer) return;
    
    // Remove focus from any focused element inside the drawer before hiding
    const activeElement = document.activeElement;
    if (activeElement && filterDrawer.contains(activeElement)) {
      activeElement.blur();
    }
    
    // Set aria-hidden before returning focus
    filterDrawer.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('drawer-open');
    unlockBodyScroll();
    
    // Return focus to the trigger button that opened the drawer
    if (drawerTriggerButton && typeof drawerTriggerButton.focus === 'function') {
      setTimeout(() => {
        drawerTriggerButton.focus();
      }, 100);
    }
  }

  // Define all filter elements first, before setting up event listeners
  const section = sectionElement;
  const priceMinInput = section.querySelector('[data-price-min]');
  const priceMaxInput = section.querySelector('[data-price-max]');
  const priceMinSlider = section.querySelector('[data-slider-min]');
  const priceMaxSlider = section.querySelector('[data-slider-max]');
  const availabilityFilter = section.querySelector('[data-availability-filter]');
  const productGrid = section.querySelector('[data-product-grid]');
  const checkboxes = section.querySelectorAll('.filter__checkbox:not([data-filter-drawer])');

  // Drawer price inputs and sliders
  const priceMinInputDrawer = section.querySelector('[data-price-min-drawer]');
  const priceMaxInputDrawer = section.querySelector('[data-price-max-drawer]');
  const priceMinSliderDrawer = section.querySelector('[data-slider-min-drawer]');
  const priceMaxSliderDrawer = section.querySelector('[data-slider-max-drawer]');
  const availabilityFilterDrawer = section.querySelector('[data-availability-filter-drawer]');
  const drawerCheckboxes = section.querySelectorAll('.filter__checkbox[data-filter-drawer]');

  console.log('Filter elements found:', {
    productGrid: !!productGrid,
    checkboxes: checkboxes.length,
    drawerCheckboxes: drawerCheckboxes.length,
    priceMinSlider: !!priceMinSlider,
    priceMaxSlider: !!priceMaxSlider
  });

  // Helper function to handle both click and touch events (for mobile compatibility)
  function addMobileEventListeners(element, handler) {
    if (!element) return;
    
    // Using let because these are reassigned on each touch event
    let touchStartTime = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    
    // Handle click events (desktop and mobile)
    element.addEventListener('click', handler);
    
    // Handle touch events (mobile)
    element.addEventListener('touchstart', function(e) {
      touchStartTime = Date.now();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    }, { passive: true });
    
    element.addEventListener('touchend', function(e) {
      const touchEndTime = Date.now();
      const timeDiff = touchEndTime - touchStartTime;
      
      // Only trigger if it was a quick tap (not a swipe or long press)
      if (timeDiff < 300) {
        const touch = e.changedTouches[0];
        const deltaX = Math.abs(touch.clientX - touchStartX);
        const deltaY = Math.abs(touch.clientY - touchStartY);
        
        // Only trigger if movement was minimal (tap, not swipe)
        if (deltaX < 10 && deltaY < 10) {
          e.preventDefault();
          e.stopPropagation();
          handler(e);
        }
      }
    });
  }

  // Drawer event listeners - attach even if drawer is initially hidden
  if (filterDrawerTrigger) {
    console.log('Attaching event listener to filter drawer trigger');
    
    const handleTriggerClick = function(e) {
      e.preventDefault();
      e.stopPropagation();
      console.log('Filter drawer trigger activated', {
        drawerExists: !!filterDrawer,
        drawerHidden: filterDrawer ? filterDrawer.getAttribute('aria-hidden') : 'N/A',
        eventType: e.type
      });
      
      const opened = openDrawer(e);
      if (!opened) {
        console.error('Failed to open drawer - check console for details');
        // Visual feedback - could add a temporary class or animation
        filterDrawerTrigger.style.opacity = '0.5';
        setTimeout(() => {
          filterDrawerTrigger.style.opacity = '1';
        }, 200);
      }
      
      // Sync drawer prices and filters when opening
      setTimeout(() => {
        // Sync price inputs
        if (priceMinInput && priceMinInputDrawer) {
          priceMinInputDrawer.value = priceMinInput.value;
        }
        if (priceMaxInput && priceMaxInputDrawer) {
          priceMaxInputDrawer.value = priceMaxInput.value;
        }
        
        // Sync price sliders
        if (priceMinSlider && priceMinSliderDrawer) {
          priceMinSliderDrawer.value = priceMinSlider.value;
        }
        if (priceMaxSlider && priceMaxSliderDrawer) {
          priceMaxSliderDrawer.value = priceMaxSlider.value;
        }
        
        // Sync availability filter
        if (availabilityFilter && availabilityFilterDrawer) {
          availabilityFilterDrawer.checked = availabilityFilter.checked;
        }
        
        // Sync checkboxes - match by filter type and value
        checkboxes.forEach((cb) => {
          const filterOption = cb.dataset.filterOption;
          const filterTag = cb.dataset.filterTag;
          const filterVendor = cb.dataset.filterVendor;
          const filterValue = cb.dataset.filterValue || cb.value;
          
          // Find matching drawer checkbox
          const drawerCb = Array.from(drawerCheckboxes).find(dc => {
            const dcOption = dc.dataset.filterOption;
            const dcTag = dc.dataset.filterTag;
            const dcVendor = dc.dataset.filterVendor;
            const dcValue = dc.dataset.filterValue || dc.value;
            
            return (filterOption && dcOption === filterOption && dcValue === filterValue) ||
                   (filterTag && dcTag === filterTag && dcValue === filterValue) ||
                   (filterVendor !== undefined && dcVendor !== undefined && dcValue === filterValue);
          });
          
          if (drawerCb) {
            drawerCb.checked = cb.checked;
          }
        });
      }, 100);
    };
    
    addMobileEventListeners(filterDrawerTrigger, handleTriggerClick);
    console.log('Filter drawer trigger button initialized successfully');
  } else {
    console.error('Filter drawer trigger button not found - drawer cannot be opened via button');
    // Try to find it again after a delay (in case DOM is still loading)
    setTimeout(() => {
      const retryTrigger = sectionElement.querySelector('[data-filter-drawer-trigger]');
      if (retryTrigger) {
        console.log('Found filter drawer trigger on retry - attaching listener');
        addMobileEventListeners(retryTrigger, function(e) {
          e.preventDefault();
          e.stopPropagation();
          openDrawer(e);
        });
      } else {
        console.error('Filter drawer trigger still not found after retry');
      }
    }, 500);
  }
  
  // Additional check: ensure drawer elements are properly initialized
  if (!filterDrawer) {
    console.error('CRITICAL: Filter drawer element not found in DOM');
    // Final retry attempt, especially important for mobile
    if (isMobile()) {
      setTimeout(() => {
        const retryDrawer = sectionElement.querySelector('[data-filter-drawer]');
        if (retryDrawer) {
          console.log('Found drawer on final retry - reinitializing...');
          // Re-run initialization if drawer is found
          const retryTrigger = sectionElement.querySelector('[data-filter-drawer-trigger]');
          if (retryTrigger && !retryTrigger.hasAttribute('data-listener-attached')) {
            retryTrigger.setAttribute('data-listener-attached', 'true');
            addMobileEventListeners(retryTrigger, function(e) {
              e.preventDefault();
              e.stopPropagation();
              openDrawer(e);
            });
          }
        }
      }, 1000);
    }
  } else {
    // Ensure drawer is properly initialized on mobile
    if (isMobile()) {
      // Ensure drawer starts in closed state
      filterDrawer.setAttribute('aria-hidden', 'true');
      // Verify drawer is in DOM and accessible
      const drawerStyle = window.getComputedStyle(filterDrawer);
      console.log('Filter drawer element found and initialized', {
        ariaHidden: filterDrawer.getAttribute('aria-hidden'),
        display: drawerStyle.display,
        visibility: drawerStyle.visibility,
        isMobile: true
      });
    } else {
      console.log('Filter drawer element found (desktop)', {
        ariaHidden: filterDrawer.getAttribute('aria-hidden'),
        display: window.getComputedStyle(filterDrawer).display
      });
    }
  }

  if (filterDrawerClose) {
    addMobileEventListeners(filterDrawerClose, function(e) {
      e.preventDefault();
      e.stopPropagation();
      closeDrawer(e);
    });
  }

  if (filterOverlay) {
    addMobileEventListeners(filterOverlay, function(e) {
      e.preventDefault();
      e.stopPropagation();
      closeDrawer(e);
    });
  }

  // Escape key to close drawer
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && filterDrawer && filterDrawer.getAttribute('aria-hidden') === 'false') {
      e.preventDefault();
      closeDrawer();
    }
  });

  // Prevent body scroll when drawer is open
  document.body.classList.remove('drawer-open');

  // Mobile filters toggle (desktop collapse)
  const filtersToggle = sectionElement.querySelector('[data-filters-toggle]');
  const filtersContent = sectionElement.querySelector('[data-filters-content]');
  
  if (filtersToggle && filtersContent) {
    filtersToggle.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      const isCollapsed = filtersContent.getAttribute('data-filters-collapsed') === 'true';
      const newState = !isCollapsed;
      filtersContent.setAttribute('data-filters-collapsed', newState ? 'true' : 'false');
      filtersToggle.setAttribute('aria-expanded', newState ? 'true' : 'false');
      console.log('Filters toggle clicked, new state:', newState ? 'collapsed' : 'expanded');
    });
    console.log('Filters toggle button initialized');
  } else {
    console.warn('Filters toggle elements not found:', {
      toggle: !!filtersToggle,
      content: !!filtersContent
    });
  }

  // Get price range from data attributes or sliders
  const minPrice = productGrid ? parseInt(productGrid.dataset.minPrice) || (priceMinSlider ? parseInt(priceMinSlider.dataset.minPrice) : 0) : 0;
  const maxPrice = productGrid ? parseInt(productGrid.dataset.maxPrice) || (priceMaxSlider ? parseInt(priceMaxSlider.dataset.maxPrice) : 100000) : 100000;

  // Format price for display
  function formatPrice(value) {
    return '' + parseInt(value).toLocaleString('en-IN');
  }

  // Parse price from display format
  function parsePrice(value) {
    if (typeof value === 'string') {
      return parseInt(value.replace(/[,]/g, '')) || 0;
    }
    return parseInt(value) || 0;
  }

  // Update price inputs from sliders (desktop)
  function updatePriceInputs(slider, input, isDrawer = false) {
    if (!slider || !input) return;
    const value = parseInt(slider.value);
    input.value = formatPrice(value);
    
    // Sync with drawer/desktop
    if (isDrawer) {
      if (priceMinInput && slider === priceMinSliderDrawer) {
        priceMinInput.value = formatPrice(value);
        if (priceMinSlider) priceMinSlider.value = value;
      }
      if (priceMaxInput && slider === priceMaxSliderDrawer) {
        priceMaxInput.value = formatPrice(value);
        if (priceMaxSlider) priceMaxSlider.value = value;
      }
    } else {
      if (priceMinInputDrawer && slider === priceMinSlider) {
        priceMinInputDrawer.value = formatPrice(value);
        if (priceMinSliderDrawer) priceMinSliderDrawer.value = value;
      }
      if (priceMaxInputDrawer && slider === priceMaxSlider) {
        priceMaxInputDrawer.value = formatPrice(value);
        if (priceMaxSliderDrawer) priceMaxSliderDrawer.value = value;
      }
    }
  }

  // Update sliders from inputs
  function updatePriceSliders(input, slider, isDrawer = false) {
    if (!input || !slider) return;
    const value = parsePrice(input.value) || 0;
    const maxValue = parseInt(slider.max) || 100000;
    slider.value = Math.min(value, maxValue);
    input.value = formatPrice(slider.value);
    
    // Sync with drawer/desktop
    if (isDrawer) {
      if (priceMinInput && input === priceMinInputDrawer) {
        priceMinInput.value = formatPrice(slider.value);
        if (priceMinSlider) priceMinSlider.value = slider.value;
      }
      if (priceMaxInput && input === priceMaxInputDrawer) {
        priceMaxInput.value = formatPrice(slider.value);
        if (priceMaxSlider) priceMaxSlider.value = slider.value;
      }
    } else {
      if (priceMinInputDrawer && input === priceMinInput) {
        priceMinInputDrawer.value = formatPrice(slider.value);
        if (priceMinSliderDrawer) priceMinSliderDrawer.value = slider.value;
      }
      if (priceMaxInputDrawer && input === priceMaxInput) {
        priceMaxInputDrawer.value = formatPrice(slider.value);
        if (priceMaxSliderDrawer) priceMaxSliderDrawer.value = slider.value;
      }
    }
  }

  // Filter products based on current filters
  function filterProducts() {
    if (!productGrid) {
      console.warn('Product grid not found');
      return;
    }

    const products = productGrid.querySelectorAll('.filtered-product-card');
    if (products.length === 0) {
      console.warn('No products found in grid');
      return;
    }
    // Use drawer values if available, otherwise desktop values
    const currentMinPrice = priceMinSliderDrawer ? parseInt(priceMinSliderDrawer.value) : (priceMinSlider ? parseInt(priceMinSlider.value) : minPrice);
    const currentMaxPrice = priceMaxSliderDrawer ? parseInt(priceMaxSliderDrawer.value) : (priceMaxSlider ? parseInt(priceMaxSlider.value) : maxPrice);
    const onlyAvailable = availabilityFilterDrawer ? availabilityFilterDrawer.checked : (availabilityFilter ? availabilityFilter.checked : false);
    
    // Get selected filter values from both desktop and drawer
    const selectedFilters = {};
    [...checkboxes, ...drawerCheckboxes].forEach(checkbox => {
      if (checkbox.checked) {
        // Using let because these are conditionally assigned
        let filterType = '';
        let filterValue = '';
        
        // Determine filter type and value
        if (checkbox.dataset.filterOption) {
          filterType = 'option-' + checkbox.dataset.filterOption;
          filterValue = checkbox.dataset.filterValue || checkbox.value;
        } else if (checkbox.dataset.filterTag) {
          filterType = 'tag-' + checkbox.dataset.filterTag;
          filterValue = checkbox.dataset.filterValue || checkbox.value;
        } else if (checkbox.dataset.filterVendor !== undefined) {
          filterType = 'vendor';
          filterValue = checkbox.dataset.filterValue || checkbox.value;
        }
        
        if (filterType && filterValue) {
          if (!selectedFilters[filterType]) {
            selectedFilters[filterType] = [];
          }
          // Normalize filter value to handleize format for comparison
          const normalizedValue = filterValue.toLowerCase().trim();
          if (!selectedFilters[filterType].includes(normalizedValue)) {
            selectedFilters[filterType].push(normalizedValue);
          }
        }
      }
    });

    // Using let because this is incremented in the loop
    let visibleCount = 0;

    products.forEach(product => {
      // Using let because this is reassigned based on filter conditions
      let shouldShow = true;

      // Price filter
      const productPrice = parseInt(product.dataset.productPrice) || 0;
      if (productPrice < currentMinPrice || productPrice > currentMaxPrice) {
        shouldShow = false;
      }

      // Availability filter
      if (onlyAvailable && shouldShow) {
        const addToCartBtn = product.querySelector('[data-add-to-cart]');
        if (addToCartBtn) {
          const variantId = addToCartBtn.dataset.variantId;
          // This would need to check actual availability via API
          // For now, we'll assume all products are available
        }
      }

      // Filter by selected options, tags, and vendor
      if (shouldShow && Object.keys(selectedFilters).length > 0) {
        for (const [filterType, filterValues] of Object.entries(selectedFilters)) {
          if (filterValues.length === 0) continue;
          
          // Using let because this is reassigned when a match is found
          let matchesFilter = false;
          
          // Check vendor filter
          if (filterType === 'vendor') {
            const productVendor = (product.dataset.productVendor || '').toLowerCase().trim();
            if (filterValues.some(value => productVendor === value.toLowerCase().trim())) {
              matchesFilter = true;
            }
          }
          // Check option filters
          else if (filterType.startsWith('option-')) {
            const productOptions = (product.dataset.productOptions || '').split(',').filter(Boolean);
            const filterKey = filterType.replace('option-', '').toLowerCase().trim();
            
            for (const filterValue of filterValues) {
              const normalizedFilterValue = filterValue.toLowerCase().trim();
              for (const option of productOptions) {
                const [optionName, optionValue] = option.split(':');
                const normalizedOptionName = (optionName || '').toLowerCase().trim();
                const normalizedOptionValue = (optionValue || '').toLowerCase().trim();
                if (normalizedOptionName === filterKey && normalizedOptionValue === normalizedFilterValue) {
                  matchesFilter = true;
                  break;
                }
              }
              if (matchesFilter) break;
            }
          }
          // Check tag filters
          else if (filterType.startsWith('tag-')) {
            const productTags = (product.dataset.productTags || '').split(',').filter(Boolean);
            const tagPrefix = filterType.replace('tag-', '').toLowerCase().trim();
            
            // Helper function to handleize a string (convert to lowercase, replace spaces/special chars with dashes)
            const handleize = (str) => {
              if (!str) return '';
              return str.toLowerCase()
                .trim()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
            };
            
            for (const filterValue of filterValues) {
              const normalizedFilterValue = handleize(filterValue);
              
              // Check if any product tag matches the filter value
              // Tags can be in format: "prefix:value", "prefix-value", or just "value"
              if (productTags.some(tag => {
                if (!tag) return false;
                
                const originalTag = tag.trim();
                const normalizedTag = handleize(originalTag);
                
                // If no prefix specified, check for exact match
                if (!tagPrefix) {
                  return normalizedTag === normalizedFilterValue;
                }
                
                // Normalize the prefix
                const normalizedPrefix = handleize(tagPrefix);
                
                // Check if tag starts with prefix (with colon or dash separator)
                const prefixWithColon = normalizedPrefix + ':';
                const prefixWithDash = normalizedPrefix + '-';
                
                // Check original tag format first (before handleizing)
                const originalLower = originalTag.toLowerCase();
                if (originalLower.startsWith(tagPrefix + ':') || originalLower.startsWith(tagPrefix + '-')) {
                  // Extract value after prefix
                  // Using let because this is conditionally reassigned
                  let tagValue = originalLower;
                  if (originalLower.startsWith(tagPrefix + ':')) {
                    tagValue = originalLower.substring(tagPrefix.length + 1).trim();
                  } else if (originalLower.startsWith(tagPrefix + '-')) {
                    tagValue = originalLower.substring(tagPrefix.length + 1).trim();
                  }
                  
                  // Compare handleized values
                  if (handleize(tagValue) === normalizedFilterValue) {
                    return true;
                  }
                }
                
                // Check handleized format
                if (normalizedTag.startsWith(normalizedPrefix + '-') || normalizedTag.startsWith(normalizedPrefix + ':')) {
                  // Using let because this is conditionally reassigned
                  let tagValue = normalizedTag;
                  if (normalizedTag.startsWith(normalizedPrefix + '-')) {
                    tagValue = normalizedTag.substring(normalizedPrefix.length + 1).trim();
                  } else if (normalizedTag.startsWith(normalizedPrefix + ':')) {
                    tagValue = normalizedTag.substring(normalizedPrefix.length + 1).trim();
                  }
                  
                  if (tagValue === normalizedFilterValue) {
                    return true;
                  }
                }
                
                // Fallback: check if normalized tag equals normalized prefix + normalized value
                if (normalizedTag === normalizedPrefix + '-' + normalizedFilterValue) {
                  return true;
                }
                
                return false;
              })) {
                matchesFilter = true;
                break;
              }
            }
          }
          
          // If this filter type has selections and product doesn't match, hide it
          if (!matchesFilter) {
            shouldShow = false;
            break;
          }
        }
      }

      if (shouldShow) {
        product.style.display = '';
        visibleCount++;
      } else {
        product.style.display = 'none';
      }
    });

    // Show empty state if no products visible
    const emptyState = productGrid.querySelector('.filtered-product-grid__empty');
    if (visibleCount === 0) {
      if (!emptyState) {
        emptyState = document.createElement('p');
        emptyState.className = 'filtered-product-grid__empty';
        emptyState.textContent = 'No products match your filters.';
        productGrid.appendChild(emptyState);
      }
    } else if (emptyState) {
      emptyState.remove();
    }
  }

  // Desktop price sliders
  if (priceMinSlider) {
    priceMinSlider.addEventListener('input', () => {
      updatePriceInputs(priceMinSlider, priceMinInput, false);
      filterProducts();
    });
  }

  if (priceMaxSlider) {
    priceMaxSlider.addEventListener('input', () => {
      updatePriceInputs(priceMaxSlider, priceMaxInput, false);
      filterProducts();
    });
  }

  if (priceMinInput) {
    priceMinInput.addEventListener('blur', () => {
      updatePriceSliders(priceMinInput, priceMinSlider, false);
      filterProducts();
    });
  }

  if (priceMaxInput) {
    priceMaxInput.addEventListener('blur', () => {
      updatePriceSliders(priceMaxInput, priceMaxSlider, false);
      filterProducts();
    });
  }

  // Drawer price sliders
  if (priceMinSliderDrawer) {
    priceMinSliderDrawer.addEventListener('input', () => {
      updatePriceInputs(priceMinSliderDrawer, priceMinInputDrawer, true);
      // Note: Don't filter on slider change in drawer - wait for Apply button
    });
  }

  if (priceMaxSliderDrawer) {
    priceMaxSliderDrawer.addEventListener('input', () => {
      updatePriceInputs(priceMaxSliderDrawer, priceMaxInputDrawer, true);
      // Note: Don't filter on slider change in drawer - wait for Apply button
    });
  }

  if (priceMinInputDrawer) {
    priceMinInputDrawer.addEventListener('blur', () => {
      updatePriceSliders(priceMinInputDrawer, priceMinSliderDrawer, true);
      // Note: Don't filter on input blur in drawer - wait for Apply button
    });
  }

  if (priceMaxInputDrawer) {
    priceMaxInputDrawer.addEventListener('blur', () => {
      updatePriceSliders(priceMaxInputDrawer, priceMaxSliderDrawer, true);
      // Note: Don't filter on input blur in drawer - wait for Apply button
    });
  }

  if (availabilityFilter) {
    availabilityFilter.addEventListener('change', filterProducts);
  }

  if (availabilityFilterDrawer) {
    availabilityFilterDrawer.addEventListener('change', () => {
      if (availabilityFilter) {
        availabilityFilter.checked = availabilityFilterDrawer.checked;
      }
      // Note: Don't filter on change in drawer - wait for Apply button
    });
  }

  // Sync checkboxes between desktop and drawer
  checkboxes.forEach((cb) => {
    cb.addEventListener('change', () => {
      // Find matching drawer checkbox by all possible attributes
      const filterOption = cb.dataset.filterOption;
      const filterTag = cb.dataset.filterTag;
      const filterVendor = cb.dataset.filterVendor;
      const filterValue = cb.dataset.filterValue || cb.value;
      
      const drawerCb = Array.from(drawerCheckboxes).find(dc => {
        const dcOption = dc.dataset.filterOption;
        const dcTag = dc.dataset.filterTag;
        const dcVendor = dc.dataset.filterVendor;
        const dcValue = dc.dataset.filterValue || dc.value;
        
        return (filterOption && dcOption === filterOption && dcValue === filterValue) ||
               (filterTag && dcTag === filterTag && dcValue === filterValue) ||
               (filterVendor !== undefined && dcVendor !== undefined && dcValue === filterValue);
      });
      
      if (drawerCb) {
        drawerCb.checked = cb.checked;
      }
      filterProducts();
    });
  });

  drawerCheckboxes.forEach((cb) => {
    cb.addEventListener('change', () => {
      // Find matching desktop checkbox by all possible attributes
      const filterOption = cb.dataset.filterOption;
      const filterTag = cb.dataset.filterTag;
      const filterVendor = cb.dataset.filterVendor;
      const filterValue = cb.dataset.filterValue || cb.value;
      
      const desktopCb = Array.from(checkboxes).find(dc => {
        const dcOption = dc.dataset.filterOption;
        const dcTag = dc.dataset.filterTag;
        const dcVendor = dc.dataset.filterVendor;
        const dcValue = dc.dataset.filterValue || dc.value;
        
        return (filterOption && dcOption === filterOption && dcValue === filterValue) ||
               (filterTag && dcTag === filterTag && dcValue === filterValue) ||
               (filterVendor !== undefined && dcVendor !== undefined && dcValue === filterValue);
      });
      
      if (desktopCb) {
        desktopCb.checked = cb.checked;
      }
      filterProducts();
    });
  });

  // Apply filters button
  const filterApply = sectionElement.querySelector('[data-filter-apply]');
  if (filterApply) {
    filterApply.addEventListener('click', () => {
      // Sync drawer filters to desktop
      if (priceMinSliderDrawer && priceMinSlider) {
        priceMinSlider.value = priceMinSliderDrawer.value;
        if (priceMinInput) priceMinInput.value = priceMinInputDrawer.value;
      }
      if (priceMaxSliderDrawer && priceMaxSlider) {
        priceMaxSlider.value = priceMaxSliderDrawer.value;
        if (priceMaxInput) priceMaxInput.value = priceMaxInputDrawer.value;
      }
      if (availabilityFilterDrawer && availabilityFilter) {
        availabilityFilter.checked = availabilityFilterDrawer.checked;
      }
      drawerCheckboxes.forEach((dc) => {
        const filterOption = dc.dataset.filterOption;
        const filterTag = dc.dataset.filterTag;
        const filterVendor = dc.dataset.filterVendor;
        const filterValue = dc.dataset.filterValue || dc.value;
        
        const desktopCb = Array.from(checkboxes).find(cb => {
          const cbOption = cb.dataset.filterOption;
          const cbTag = cb.dataset.filterTag;
          const cbVendor = cb.dataset.filterVendor;
          const cbValue = cb.dataset.filterValue || cb.value;
          
          return (filterOption && cbOption === filterOption && cbValue === filterValue) ||
                 (filterTag && cbTag === filterTag && cbValue === filterValue) ||
                 (filterVendor !== undefined && cbVendor !== undefined && cbValue === filterValue);
        });
        
        if (desktopCb) {
          desktopCb.checked = dc.checked;
        }
      });
      filterProducts();
      closeDrawer();
    });
  }

  // Clear all filters button
  const filterClear = sectionElement.querySelector('[data-filter-clear]');
  if (filterClear) {
    filterClear.addEventListener('click', () => {
      // Clear all checkboxes
      [...checkboxes, ...drawerCheckboxes].forEach(cb => {
        cb.checked = false;
      });
      
      // Reset price sliders
      if (priceMinSlider) priceMinSlider.value = minPrice;
      if (priceMaxSlider) priceMaxSlider.value = maxPrice;
      if (priceMinSliderDrawer) priceMinSliderDrawer.value = minPrice;
      if (priceMaxSliderDrawer) priceMaxSliderDrawer.value = maxPrice;
      
      // Reset price inputs
      if (priceMinInput) updatePriceInputs(priceMinSlider, priceMinInput, false);
      if (priceMaxInput) updatePriceInputs(priceMaxSlider, priceMaxInput, false);
      if (priceMinInputDrawer) updatePriceInputs(priceMinSliderDrawer, priceMinInputDrawer, true);
      if (priceMaxInputDrawer) updatePriceInputs(priceMaxSliderDrawer, priceMaxInputDrawer, true);
      
      // Reset availability
      if (availabilityFilter) availabilityFilter.checked = false;
      if (availabilityFilterDrawer) availabilityFilterDrawer.checked = false;
      
      filterProducts();
    });
  }

  // Initialize
  if (priceMinSlider && priceMinInput) {
    updatePriceInputs(priceMinSlider, priceMinInput, false);
  }
  if (priceMaxSlider && priceMaxInput) {
    updatePriceInputs(priceMaxSlider, priceMaxInput, false);
  }
  if (priceMinSliderDrawer && priceMinInputDrawer) {
    updatePriceInputs(priceMinSliderDrawer, priceMinInputDrawer, true);
  }
  if (priceMaxSliderDrawer && priceMaxInputDrawer) {
    updatePriceInputs(priceMaxSliderDrawer, priceMaxInputDrawer, true);
  }

  // Initialize filters as collapsed on mobile only
  if (window.innerWidth <= 992 && filtersContent) {
    filtersContent.setAttribute('data-filters-collapsed', 'true');
    if (filtersToggle) {
      filtersToggle.setAttribute('aria-expanded', 'false');
    }
  } else if (filtersContent) {
    // On desktop, ensure filters are always visible
    filtersContent.removeAttribute('data-filters-collapsed');
    if (filtersToggle) {
      filtersToggle.setAttribute('aria-expanded', 'true');
    }
  }

  // Ensure drawer is properly initialized on mobile
  if (isMobile() && filterDrawer) {
    // Ensure drawer starts closed
    filterDrawer.setAttribute('aria-hidden', 'true');
    // Verify drawer elements are accessible
    if (filterPanel) {
      filterPanel.style.display = 'flex';
      filterPanel.style.visibility = 'visible';
    }
    console.log('Mobile drawer initialized', {
      ariaHidden: filterDrawer.getAttribute('aria-hidden'),
      panelExists: !!filterPanel
    });
  }

  // Initial filter run to show all products
  filterProducts();

  // Handle window resize
  window.addEventListener('resize', ThemeUtils.debounce(function() {
    const currentIsMobile = isMobile();
    
    if (window.innerWidth <= 992 && filtersContent) {
      // On mobile, ensure toggle is visible and check current state
      if (filtersToggle) {
        const isCollapsed = filtersContent.getAttribute('data-filters-collapsed') === 'true';
        filtersToggle.setAttribute('aria-expanded', !isCollapsed ? 'true' : 'false');
      }
    } else {
      // On desktop, always show filters
      if (filtersContent) {
        filtersContent.removeAttribute('data-filters-collapsed');
      }
      if (filtersToggle) {
        filtersToggle.setAttribute('aria-expanded', 'true');
      }
    }
    
    // Ensure drawer state is correct on resize
    if (filterDrawer) {
      // If switching to mobile and drawer is open, ensure it's properly displayed
      if (currentIsMobile && filterDrawer.getAttribute('aria-hidden') === 'false') {
        filterDrawer.setAttribute('aria-hidden', 'false'); // Force update
        if (filterPanel) {
          filterPanel.style.display = 'flex';
          filterPanel.style.visibility = 'visible';
        }
      }
    }
  }, 150));
  } // End of initFilteredProductGrid function

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFilteredProductGrid);
  } else {
    // DOM already loaded, but wait a tick to ensure all elements are rendered
    setTimeout(initFilteredProductGrid, 0);
  }
  
  // Fallback: Try to initialize again after a short delay if elements weren't found
  setTimeout(() => {
    const sectionElement = document.querySelector('[id^="filtered-product-grid-"]');
    if (sectionElement) {
      const trigger = sectionElement.querySelector('[data-filter-drawer-trigger]');
      const drawer = sectionElement.querySelector('[data-filter-drawer]');
      
      // If trigger exists but drawer doesn't, log a warning
      if (trigger && !drawer) {
        console.warn('Filter trigger button found but drawer element is missing from DOM');
      }
      
      // If drawer exists but trigger doesn't, log a warning
      if (drawer && !trigger) {
        console.warn('Filter drawer found but trigger button is missing from DOM');
      }
    }
  }, 1000);
})();
{% endjavascript %}

{% schema %}
{
  "name": "Filtered Product Grid",
  "tag": "section",
  "class": "filtered-product-grid-section",
  "settings": [
    {
      "type": "text",
      "id": "title",
      "label": "Section Title",
      "default": "Products",
      "info": "Leave empty to use collection title"
    },
    {
      "type": "collection",
      "id": "collection",
      "label": "Collection",
      "info": "Select a collection to display products from. If left empty and used on a collection page, it will automatically use the current collection."
    },
    {
      "type": "range",
      "id": "products_per_page",
      "label": "Products per page",
      "min": 6,
      "max": 24,
      "step": 3,
      "default": 9
    }
  ],
  "blocks": [
    {
      "type": "filter_group",
      "name": "Filter Group",
      "settings": [
        {
          "type": "text",
          "id": "title",
          "label": "Filter Title",
          "default": "Filter"
        },
        {
          "type": "select",
          "id": "filter_type",
          "label": "Filter Type",
          "options": [
            {
              "value": "product_option",
              "label": "Product Option"
            },
            {
              "value": "product_tag",
              "label": "Product Tag"
            },
            {
              "value": "vendor",
              "label": "Vendor"
            },
            {
              "value": "metafield",
              "label": "Metafield"
            }
          ],
          "default": "product_option"
        },
        {
          "type": "text",
          "id": "option_name",
          "label": "Option Name",
          "info": "For Product Option type: e.g., 'Screen size', 'Ram', 'Operating system'",
          "default": "Size"
        },
        {
          "type": "text",
          "id": "tag_prefix",
          "label": "Tag Prefix",
          "info": "For Product Tag type: e.g., 'brand:' for tags like 'brand:lenovo'",
          "default": "brand:"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "Filtered Product Grid",
      "settings": {
        "title": "Laptops",
        "products_per_page": 9
      },
      "blocks": [
        {
          "type": "filter_group",
          "settings": {
            "title": "Screen size",
            "filter_type": "product_option",
            "option_name": "Screen size"
          }
        },
        {
          "type": "filter_group",
          "settings": {
            "title": "Ram",
            "filter_type": "product_option",
            "option_name": "Ram"
          }
        },
        {
          "type": "filter_group",
          "settings": {
            "title": "Brand",
            "filter_type": "vendor"
          }
        },
        {
          "type": "filter_group",
          "settings": {
            "title": "Operating system",
            "filter_type": "product_option",
            "option_name": "Operating system"
          }
        },
        {
          "type": "filter_group",
          "settings": {
            "title": "Internal memory type",
            "filter_type": "product_option",
            "option_name": "Internal memory type"
          }
        },
        {
          "type": "filter_group",
          "settings": {
            "title": "Image refresh rate",
            "filter_type": "product_option",
            "option_name": "Image refresh rate"
          }
        }
      ]
    }
  ]
}
{% endschema %}
